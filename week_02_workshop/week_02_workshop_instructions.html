<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="The Graph Courses">

<title>Workshop 2: Automated Data Analysis &amp; Reporting</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="week_02_workshop_instructions_files/libs/clipboard/clipboard.min.js"></script>
<script src="week_02_workshop_instructions_files/libs/quarto-html/quarto.js"></script>
<script src="week_02_workshop_instructions_files/libs/quarto-html/popper.min.js"></script>
<script src="week_02_workshop_instructions_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="week_02_workshop_instructions_files/libs/quarto-html/anchor.min.js"></script>
<link href="week_02_workshop_instructions_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="week_02_workshop_instructions_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="week_02_workshop_instructions_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="week_02_workshop_instructions_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="week_02_workshop_instructions_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Workshop 2: Automated Data Analysis &amp; Reporting</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>The Graph Courses </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Welcome to another session of your Generative AI Workshop! In this session, you’ll use Data Analysis AI tools to compile a brief report.</p>
<p>Your task is to create a data report (HTML or PDF) analyzing the relationship between two chosen country indicators from the Gapminder data repository here: <a href="https://gapminder.org/data">https://gapminder.org/data</a>.</p>
<section id="your-final-report-should-contain" class="level2">
<h2 class="anchored" data-anchor-id="your-final-report-should-contain">Your final report should contain:</h2>
<ol type="1">
<li>A choropleth world map of your first selected indicator (for the chosen recent year).</li>
<li>A choropleth world map of your second selected indicator (for the chosen recent year).</li>
<li>A scatterplot showing the relationship between your two chosen indicators.</li>
<li>A description and interpretation of the relationship between the two indicators. This may include a correlation coefficient (e.g., Pearson’s <span class="math inline">\(r\)</span>) if appropriate, or a qualitative description based on the scatterplot.</li>
</ol>
</section>
<section id="tool-tracks" class="level2">
<h2 class="anchored" data-anchor-id="tool-tracks">Tool Tracks</h2>
<p>You will choose one of the following tools based on your coding experience:</p>
<ul>
<li><p><strong>Students WITH significant coding experience in R:</strong> You should use <strong>Cursor</strong>, an AI-powered code editor, with R.</p></li>
<li><p><strong>Students WITHOUT significant coding experience:</strong> You will use <strong>Julius</strong>, a more user-friendly AI data analysis tool with a chat interface.</p></li>
<li><p><strong>If you finish your assigned tool track early, you are encouraged to try the other one!</strong></p></li>
</ul>
<hr>
</section>
</section>
<section id="part-1-general-setup-data-selection-all-students" class="level1">
<h1>Part 1: General Setup &amp; Data Selection (All Students)</h1>
<ol type="1">
<li><strong>Choose Your Data:</strong>
<ul>
<li>Go to Gapminder’s data repository: <a href="https://gapminder.org/data">https://gapminder.org/data</a></li>
<li>Browse the indicators and <strong>select TWO indicators</strong> that you hypothesize might be related.
<ul>
<li><em>Think about what story you want to explore. For example, a famous relationship is GDP per capita vs.&nbsp;Life Expectancy. Consider other potential meaningful connections.</em></li>
</ul></li>
<li>For each chosen indicator, download the data as a CSV file.</li>
</ul></li>
<li><strong>Data Preparation Note: Data will be subsetted to a single year:</strong>
<ul>
<li>After loading your data into Cursor or Julius, you will need to <strong>subset it to the most recent year that has good data coverage</strong>. “Good data coverage” means not too many missing values.</li>
<li>This means that when you are choosing your indicators, you should choose indicators that have good data coverage for the same recent years.</li>
</ul></li>
</ol>
<hr>
</section>
<section id="part-2-tool-specific-instructions" class="level1">
<h1>Part 2: Tool-Specific Instructions</h1>
<p>Please follow the instructions for the tool assigned to your group.</p>
<section id="section-a-for-students-with-coding-experience-using-cursor-with-r" class="level2">
<h2 class="anchored" data-anchor-id="section-a-for-students-with-coding-experience-using-cursor-with-r">Section A: For Students WITH Coding Experience (Using Cursor with R)</h2>
<p>You will use Cursor to generate an R Markdown report.</p>
<ol type="1">
<li><p><strong>Setup Cursor:</strong></p>
<ul>
<li><p>You’ll need to set up Cursor and can use their free 14-day trial.</p></li>
<li><p><strong>Watch our setup video before you begin:</strong> <a href="https://thegraphcourses.org/courses/aiw-2025-q2/topics/ai-automated-data-analysis-with-r-and-cursor-for-r-users-only/">AI Automated Data Analysis with R and Cursor (for R users only)</a></p></li>
</ul></li>
<li><p><strong>Project folder:</strong></p>
<ul>
<li>Create a new project folder on your computer. Place the two CSV files you downloaded from Gapminder into this folder.</li>
</ul></li>
<li><p><strong>Generating Your Report in Cursor:</strong></p>
<ul>
<li><p>Open your project folder in Cursor. Create a new R Markdown (<code>.Rmd</code>) file with an appropriate name.</p></li>
<li><p>Then use Cursor’s “Agent Mode” to help you write the R code and narrative.</p></li>
<li><p><strong>Initial Agent Prompt Idea:</strong> Here is an example of an initial agent prompt:</p>
<pre><code>You are an AI agent that creates elegant data reports.
You will create reports by writing code to an Rmarkdown file (with github_document output), knitting that file, then reading the output md file to validate.
You repeat this edit, knit, review loop until the reporting task is achieved.
Use plots, tables, and inline R code as needed.</code></pre></li>
<li><p><strong>Specific Task Prompting Example:</strong></p>
<pre><code>Now create a data report in my Rmd file using the two datasets I've provided ([indicator1] and [indicator2]).

The report should:
1. Load both datasets.
2. For each indicator, identify the most recent year with good data coverage (e.g., less than 30% missing values). Subset the data to this year.
3. Create a choropleth world map for the first indicator for that year.
4. Create a choropleth world map for the second indicator for that year.
5. Merge the data for the two indicators for the chosen year.
6. Create a scatterplot showing the relationship between these two indicators.
7. Provide a brief interpretation of the relationship shown in the scatterplot (you can calculate Pearson's correlation coefficient $$r$$ if it's helpful).
Ensure all plots are clearly titled and labeled.
</code></pre>
<ul>
<li><em>Remember to replace <code>[indicator1]</code> and <code>[indicator2]</code> with your actual indicator names.</em></li>
</ul></li>
<li><p><strong>Iterate and Refine:</strong> Work with the agent to refine the figures and text until you are happy with the report. You can ask it to change the title of a plot, or to use a different color scheme, for example.</p></li>
<li><p><strong>NOTE:</strong> Cursor cannot see your plots. It may hallucinate interpretations of the plots that are inaccurate. You can ignore these.</p></li>
</ul></li>
<li><p><strong>Final Output:</strong> Your primary submission will be the HTML file generated from knitting your R Markdown file.</p></li>
</ol>
<p>(That is, while your AI agent will output the report as an .md file while it is working, you should change the output format when you are done and ready to submit. To do this, in your .Rmd file, change <code>output: github_document</code> to <code>output: html_document</code> in the header section before your final knit.)</p>
</section>
<section id="section-b-for-students-without-prior-coding-experience-using-julius" class="level2">
<h2 class="anchored" data-anchor-id="section-b-for-students-without-prior-coding-experience-using-julius">Section B: For Students WITHOUT Prior Coding Experience (Using Julius)</h2>
<p>You will use Julius, an AI data analysis chat-based tool, to analyze your data and generate content for your report.</p>
<ol type="1">
<li><p><strong>Setup Julius:</strong></p>
<ul>
<li>Go to <a href="https://julius.ai/">Julius.ai</a> and sign up.</li>
<li>For a 2-week trial of premium features, go to your <strong>Settings</strong>, then <strong>Usage</strong>, and under <strong>Institutional Codes</strong>, enter: <code>GRAPHAIR</code></li>
<li><strong>Please do not share this code.</strong></li>
</ul></li>
<li><p><strong>Analyzing Data &amp; Generating Content with Julius:</strong></p>
<ul>
<li><p>Start a new conversation in Julius and upload your two CSV files.</p></li>
<li><p><strong>Chat with Julius Example Prompt:</strong></p>
<pre><code>I've uploaded two datasets, which contain indicators on [indicator1] and [indicator2].

I am writing a report on the relationship between the indicators [indicator1] and [indicator2].

Please help me do the following:
1. For each indicator, find the most recent year where data is available for at least 70% of countries. 
2. Create a choropleth world map for the first indicator using data from its best recent year.
3. Create a choropleth world map for the second indicator using data from that same year if possible, or the most recent year with good data coverage if not.
4. Now merge the data for the chosen indicators and the chosen years.
5. Create a scatterplot showing the relationship between these two indicators.
6. Describe the relationship shown in the scatterplot? If relevant, calculate Pearson's correlation coefficient ($$r$$), but mainly explain what you see in simple terms.
Make sure the plots have good titles and labels.</code></pre>
<ul>
<li><em>Remember to replace <code>[indicator1]</code> and <code>[indicator2]</code> with your actual indicator names.</em></li>
</ul></li>
<li><p><strong>Review and Refine:</strong> Julius will show its steps, data, and plots. Work with it to refine the figures and text until you are happy with the output plots. You can ask it to change the title of a plot, or to use a different color scheme, for example.</p></li>
</ul></li>
<li><p><strong>Creating Your PDF Report from Julius Output:</strong></p>
<ul>
<li>Export your conversation from Julius (to DOCX). To do this click on the “…” button in the top right corner of the conversation, select “Download” and then “Download as DOCX”.</li>
<li><strong>Edit the DOCX:</strong> The DOCX file will contain your chat history with the model. You now need to delete your prompts and conversational filler. Keep only the key outputs: plots and interpretations. Organize it into a clean report with your name and date.</li>
<li><strong>Export as PDF</strong> from your word processor.</li>
</ul></li>
<li><p><strong>Final Output:</strong> Your primary submission will be the PDF file.</p></li>
</ol>
<hr>
</section>
</section>
<section id="part-3-submission" class="level1">
<h1>Part 3: Submission</h1>
<ul>
<li>Upload your final report file (HTML or PDF) to the designated submission link on the course workshop page.</li>
</ul>
<hr>
</section>
<section id="part-4-optional---add-to-your-github-pages-portfolio" class="level1">
<h1>Part 4: Optional - Add to Your GitHub Pages Portfolio</h1>
<p>As a final step, you can add your report to your portfolio website which you created earlier in the course.</p>
<ol type="1">
<li><p><strong>Upload your Report:</strong> Add your final report file (HTML or PDF) to the GitHub repository that hosts your portfolio website.</p></li>
<li><p><strong>Get the Link:</strong> Once uploaded, navigate to the file in your GitHub repository and copy its direct link.</p></li>
<li><p><strong>Update Your Portfolio with ChatGPT:</strong></p>
<ul>
<li><p>Go back to the ChatGPT conversation you used to build your portfolio website. (If you don’t have it, you can start a new one, provide ChatGPT with your existing <code>index.html</code> file content, and then give it the new instructions).</p></li>
<li><p>Ask ChatGPT to add a new entry for this workshop. For example:</p>
<pre><code>Please update my portfolio website. I want to add a new project for "Workshop 2: Automated Data Analysis".
Include a brief description like "Analyzed Gapminder data to explore relationships between two global indicators using AI tools."
Then, add a link to my report: [paste the direct link to your uploaded report file here]</code></pre></li>
<li><p>ChatGPT will provide you with updated <code>index.html</code> code. Replace the content of your <code>index.html</code> file in your GitHub repository with this new code. Commit and push the changes.</p></li>
<li><p>Verify that your live GitHub Pages site now shows the new entry and the link works.</p></li>
</ul></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>